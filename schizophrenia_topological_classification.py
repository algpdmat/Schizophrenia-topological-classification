# -*- coding: utf-8 -*-
"""Schizophrenia topological classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hmQDnyy7hKCOTbgJDHS6f3Zm53aRVeAq
"""

import networkx as nx
import numpy as np

def calcular_metricas_grafo(grafo):
    degree_centrality = np.mean(list(nx.degree_centrality(grafo).values()))
    betweenness_centrality = np.mean(list(nx.betweenness_centrality(grafo).values()))
    eigenvector_centrality = np.mean(list(nx.eigenvector_centrality(grafo).values()))
    closeness_centrality = np.mean(list(nx.closeness_centrality(grafo).values()))

    return {
        "degree_centrality": degree_centrality,
        "betweenness_centrality": betweenness_centrality,
        "eigenvector_centrality": eigenvector_centrality,
        "closeness_centrality": closeness_centrality
    }


def calcular_metricas_grafo(grafo):
    degree_centrality = np.mean(list(nx.degree_centrality(grafo).values()))
    betweenness_centrality = np.mean(list(nx.betweenness_centrality(grafo).values()))
    eigenvector_centrality = np.mean(list(nx.eigenvector_centrality_numpy(grafo).values()))
    closeness_centrality = np.mean(list(nx.closeness_centrality(grafo).values()))

    return {
        "Degree Centrality": degree_centrality,
        "Betweenness Centrality": betweenness_centrality,
        "Eigenvector Centrality": eigenvector_centrality,
        "Closeness Centrality": closeness_centrality
    }

def classificar_grupo(grafo):
    # Dados da tabela incorporados na função
    dados_grupo = {
        "CE": {"Modularidade": (0.50, 0.68), "Degree Centrality Mean": 0.047841, "Betweenness Centrality Mean": 0.092061, "Eigenvector Centrality Mean": 0.091057, "Closeness Centrality Mean": 0.200616},
        "CEL": {"Modularidade": (0.52, 0.70), "Degree Centrality Mean": 0.050714, "Betweenness Centrality Mean": 0.101915, "Eigenvector Centrality Mean": 0.096371, "Closeness Centrality Mean": 0.194611},
        "CN": {"Modularidade": (0.49, 0.67), "Degree Centrality Mean": 0.056246, "Betweenness Centrality Mean": 0.121311, "Eigenvector Centrality Mean": 0.104998, "Closeness Centrality Mean": 0.199179}
    }

    # Calcula as métricas do grafo
    metricas = calcular_metricas_grafo(grafo)

    # Comparação das métricas com cada grupo
    grupo_mais_provavel = None
    menor_diferenca = float('inf')

    for grupo, valores in dados_grupo.items():
      diferenca = sum(abs(metricas[metrica] - valores[metrica + " Mean"]) for metrica in metricas)

        # Atualiza o grupo mais provável se a diferença for menor
      if diferenca < menor_diferenca:
        menor_diferenca = diferenca
        grupo_mais_provavel = grupo

    return grupo_mais_provavel

def calculate_and_visualize_forman_ricci_curvature(G):
    """
    Calcula a curvatura de Forman-Ricci para cada aresta de um grafo G e, em seguida, visualiza o grafo.

    Parâmetros:
    G (nx.Graph): Um grafo NetworkX.
    """

    # Calculando a curvatura de Forman-Ricci para cada aresta do grafo
    for edge in G.edges():
        v1, v2 = edge
        w_e = G[v1][v2].get('weight', 1.0)
        w_v1 = G.degree(v1, weight='weight')
        w_v2 = G.degree(v2, weight='weight')
        forman_curvature = 4 - (w_v1 + w_v2) / w_e
        G[v1][v2]['formanCurvature'] = forman_curvature

    # Visualização do grafo com curvatura de Forman-Ricci
    pos = nx.spring_layout(G)
    edge_colors = [G[u][v]['formanCurvature'] for u, v in G.edges()]
    edge_widths = [2 + abs(G[u][v]['formanCurvature']) / 2 for u, v in G.edges()]

    nx.draw(G, pos, with_labels=True, edge_color=edge_colors, width=edge_widths,
            edge_cmap=plt.cm.coolwarm, node_color='lightblue')

    sm = plt.cm.ScalarMappable(cmap=plt.cm.coolwarm, norm=plt.Normalize(vmin=min(edge_colors), vmax=max(edge_colors)))
    sm.set_array([])
    plt.colorbar(sm, label='Forman-Ricci Curvature')
    plt.title("Visualização do Grafo com Curvatura de Forman-Ricci")
    plt.show()

def calculate_and_visualize_top10_centralities(G):
    """
    Calcula várias centralidades para um grafo G e visualiza o grafo destacando os top 10 nós
    de cada centralidade. Cores misturadas são usadas para nós que são top em múltiplas centralidades.

    Parâmetros:
    G (nx.Graph): Um grafo NetworkX.
    """
    # Calculando centralidades
    bet_centrality = nx.betweenness_centrality(G)
    deg_centrality = nx.degree_centrality(G)
    eig_centrality = nx.eigenvector_centrality(G, max_iter=1000)
    clo_centrality = nx.closeness_centrality(G)

    # Encontrando os top 10 nós para cada centralidade
    top_bet = sorted(bet_centrality, key=bet_centrality.get, reverse=True)[:10]
    top_deg = sorted(deg_centrality, key=deg_centrality.get, reverse=True)[:10]
    top_eig = sorted(eig_centrality, key=eig_centrality.get, reverse=True)[:10]
    top_clo = sorted(clo_centrality, key=clo_centrality.get, reverse=True)[:10]

    # Definindo cores para cada centralidade
    colors = {
        'bet': np.array([1, 0, 0]),  # Vermelho
        'deg': np.array([0, 1, 0]),  # Verde
        'eig': np.array([0, 0, 1]),  # Azul
        'clo': np.array([1, 0, 1])   # Roxo
    }

    # Inicializando a cor de cada nó como cinza claro
    node_colors = {node: np.array([0.8, 0.8, 0.8]) for node in G.nodes()}

    # Atualizando a cor dos nós baseado nas top centralidades
    for node in G.nodes():
        if node in top_bet:
            node_colors[node] += colors['bet']
        if node in top_deg:
            node_colors[node] += colors['deg']
        if node in top_eig:
            node_colors[node] += colors['eig']
        if node in top_clo:
            node_colors[node] += colors['clo']
        node_colors[node] = np.clip(node_colors[node], 0, 1)  # Limitando a cor para o intervalo [0, 1]

    # Posicionamento dos nós
    pos = nx.spring_layout(G)

    # Desenhar o grafo
    nx.draw(G, pos, with_labels=True, node_color=[node_colors[node] for node in G.nodes()])

    # Criando a legenda
    plt.scatter([], [], color=colors['bet'], label='Top 10 Betweenness')
    plt.scatter([], [], color=colors['deg'], label='Top 10 Degree')
    plt.scatter([], [], color=colors['eig'], label='Top 10 Eigenvector')
    plt.scatter([], [], color=colors['clo'], label='Top 10 Closeness')
    plt.legend()

    plt.title("Visualização do Grafo com Top 10 Centralidades")
    plt.show()

def calculate_forman_ricci_curvature(G):
    for u, v in G.edges():
        curvature = 4 - (G.degree(u) + G.degree(v))
        G[u][v]['formanCurvature'] = curvature
    return G


def process_and_visualize_graph(G):
    """
    Processa um grafo NetworkX: calcula a curvatura de Forman-Ricci e visualiza o grafo com as curvaturas nas arestas.

    Parâmetros:
    G (nx.Graph): Um grafo NetworkX.
    """
    # Calcular a curvatura de Forman-Ricci
    G = calculate_forman_ricci_curvature(G)

    # Desenhar o grafo
    pos = nx.spring_layout(G)  # Layout para o grafo
    edges = G.edges(data=True)
    curvaturas = [edata['formanCurvature'] for _, _, edata in edges]

    # Mapear as curvaturas para cores
    curvatura_min = min(curvaturas)
    curvatura_max = max(curvaturas)
    colors = [plt.cm.coolwarm((curv - curvatura_min) / (curvatura_max - curvatura_min)) for curv in curvaturas]

    # Desenhar arestas com cores baseadas na curvatura
    nx.draw_networkx_edges(G, pos, edge_color=colors, width=2)

    # Desenhar nós
    nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=50)

    # Adicionar rótulos (opcional)
    nx.draw_networkx_labels(G, pos)

    # Mostrar a barra de cores para as curvaturas
    sm = plt.cm.ScalarMappable(cmap=plt.cm.coolwarm, norm=plt.Normalize(vmin=curvatura_min, vmax=curvatura_max))
    sm.set_array([])
    plt.colorbar(sm, label='Forman-Ricci Curvature')

    plt.title("Visualização do Grafo com Curvatura de Forman-Ricci")
    plt.axis('off')
    plt.show()